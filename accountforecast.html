<html>
<head>
<title>Account Forecast (&beta;)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type='text/css'>
body, table, td, select, input, p, li
{
  font-size: 10px;
  font-family: "Lucida Console", Monaco, monospace;
}

button, input
{
  width: 83px;
  height: 22px;
  text-align: center;
}

.checkbox
{
  width: 12px;
  height: 12px;
  vertical-align: middle;
}

table
{
  border-collapse: collapse;
}

.starts
{
  border: 0;
  padding: 0;
}

table, td, th
{
  border: 1px solid black;
}

td
{
  padding: 1px;
  text-align: center;
  vertical-align: middle;
}

.left
{
  text-align: left;
}

.right
{
  text-align: right;
}

th
{
  background-color: #BBB;
}

ul
{
  list-style: square;
  margin-left: 0;
}

li ul
{
  margin-left: 0;
}

.grabber
{
  text-align: center;
  vertical-align: middle;
}

.colorpicker
{
  opacity: 0;
  width: 14px;
  height: 14px;
  cursor: cell;
}

.colorpicker::-webkit-appearance
{
  border: none;
}

.colorpicker::-webkit-color-swatch-wrapper
{
  padding: 0;
}

.colorpicker::-webkit-color-swatch
{
  border: none;
}

.x
{
  border-color: #999999;
  background-color: darkred;
  border-width: 1;
  font-weight: 900;
  color: white;
  width: 12px;
  height: 12px;
  text-align: center;
  vertical-align: middle;
  cursor: pointer;
  display: inline-block;
}

.info
{
  color: #333333;
  font-size: 10px;
}

.loadlabel
{
  width: 83;
  text-align: center;
  vertical-align: middle;
  display: inline-block;
}

.datefield
{
  width: 123px;
}

.balfield
{
  width: 123px;
}

.warnbutton
{
  background-color: #FF5555;
}

.outborder
{
  border-top: thin solid black;
  border-bottom: thin solid black;
  border-left: thin solid black;
  border-right: thin solid black;
}

.outbordersep
{
  border-top: thick solid black;
  border-bottom: thin solid black;
  border-left: thin solid black;
  border-right: thin solid black;
}

.outborderlow
{
  background-color: #ffcccc; /* semi-light red */
  border: 2px dashed red !important;
}
.outborderhigh
{
  background-color: #ccffcc; /* semi-light green */
  border: 2px dashed #00cc00 !important; /* bright green */
}
.outborderwarn
{
  background-color: #ffffcc; /* yellow */
  border: 2px dashed red !important;
}

.pointer
{
  position: absolute;
  height: 10px;
  font-size: 10px;
  font-weight: bold;
  text-align: center;
  width: 85px;
  visibility: hidden;
  z-index: 10;
}

.lowpointer
{
  border: 1px dashed red;
  background-color: #ffcccc; /* semi-light red */
}
.highpointer
{
    border: 1px dashed #00cc00; /* bright green */
    background-color: #ccffcc; /* semi-light green */
}
.warnpointer
{
    border: 1px dashed red;
    background-color: #ffffcc; /* yellow */
}

.sorter
{
  cursor: grab;
  width: 14px;
}

.tooltip
{
  position: relative;
  display: inline-block;
}

.tooltip .tooltiptext
{
  visibility: hidden;
  width: 120;
  background-color: black;
  color: #fff;
  text-align: center;
  padding: 5 0;
  border-radius: 6;
  position: absolute;
  z-index: 1;
}

.tooltip:hover .tooltiptext
{
  visibility: visible;
}

.colorpickerContainer
{
  position: relative;
  width: 14px;
  height: 14px;
}

.colorpickerPen, .colorpickerTool
{
  width: 14px;
  height: 14px;
  position: absolute;
  top: 0;
  left: 0;
  font-weight: 900;
}

.colorpickerTool
{
  z-index: 10;
}
</style>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/datejs/1.0/date.min.js"></script>
<script type="text/javascript">
'use strict';

// --- Constants for Readability and Maintenance ---
const GRABBER_COL = 0;
const START_DATE_COL = 1;
const END_DATE_COL = 2;
const NAME_COL = 3;
const FREQ_COL = 4;
const DEBIT_COL = 5;
const CREDIT_COL = 6;
const COLOR_COL = 7;
const DELETE_COL = 8;
const CSV_METADATA_MARKER = "DEFINE-STARTS";
const DEFAULT_ROW_COLOR = "#F5F5F5";
const HEADER_COLOR = "#BBBBBB";
const GRABBER_COLOR = "#A9A9A9";

let ForecastArr = [];

function BadCell(aCell) {
  aCell.bgColor = "#FFCC00";
}

function OkCell(aCell) {
  aCell.bgColor = aCell.parentNode.cells[COLOR_COL].getElementsByClassName('colorpicker')[0].value;
}

function removeTags(html) {
  const tagBody = '(?:[^"\'>]|"[^"]*"|\'[^\']*\')*';
  const tagOrComment = new RegExp('<(?:' + '!--(?:(?:-*[^->])*--+|-?)' + '|script\\b' + tagBody + '>[\\s\\S]*?</script\\s*' + '|style\\b' + tagBody + '>[\\s\\S]*?</style\\s*' + '|/?[a-z]' + tagBody + ')>', 'gi');
  let oldHtml;
  do {
    oldHtml = html;
    html = html.replace(tagOrComment, '');
  } while (html !== oldHtml);
  return html.replace(/</g, '&lt;');
}

function BuildDataToSave() {
  const table = document.getElementById("InOutTableBody");
  let buildData = "";
  for (let r = 0; r < table.rows.length; r++) {
    for (let c = 1; c < 8; c++) {
      if (table.rows[0].cells[c].cellIndex < COLOR_COL) {
        buildData = buildData + table.rows[r].cells[c].innerHTML + ",";
      } else {
        buildData = buildData + table.rows[r].cells[c].getElementsByClassName('colorpicker')[0].value + "\r\n";
      }
    }
  }
  buildData = buildData + document.getElementById("StartDate").value + ",";
  buildData = buildData + document.getElementById("EndDate").value + `,${CSV_METADATA_MARKER},`;
  buildData = buildData + document.getElementById("StartBal").value + "\r\n";
  return buildData;
}

function SaveBuildData() {
  const buildData = BuildDataToSave();
  localStorage["ForeCastArr"] = JSON.stringify(buildData);
}

function LoadBuildData() {
  const cArr = JSON.parse(localStorage["ForeCastArr"]);
  LoadTable(cArr);
  const LoadTime = new Date().toString('yyyy-MM-dd HH:mm:ss');
  LoadInfo.innerHTML = "Data Source: (browser storage) @ " + LoadTime;
}

function ValidateCell(e) {
  const aCell = e.target || window.event.srcElement;
  const aCellValRaw = aCell.innerHTML;
  const aCellVal = removeTags(aCellValRaw);
  aCell.innerHTML = aCellVal;
  const LowerVal = aCellVal.toLowerCase() || "";

  if (aCell.cellIndex <= END_DATE_COL) { // start and end cols
    if (aCell.cellIndex == END_DATE_COL) {
      if (LowerVal == "none" || LowerVal === "") {
        aCell.innerHTML = "none";
        OkCell(aCell);
        return true;
      }
    }
    const NumArr = aCellVal.match(/\d+\.?\d*/g);
    if (NumArr === null || NumArr.length > 3) {
      BadCell(aCell);
      return true;
    }
    if (NumArr.length == 2) {
      if (NumArr[0].length < 3 && NumArr[1].length < 3) {
        NumArr[2] = NumArr[1];
        NumArr[1] = NumArr[0];
        NumArr[0] = Date.today().toString('yyyy-MM-dd');
      } else {
        BadCell(aCell);
        return true;
      }
    }
    if (NumArr.length === 3 && NumArr[2].length == 4) {
      let tmpnum = NumArr[0];
      NumArr[0] = NumArr[2];
      NumArr[2] = NumArr[1];
      NumArr[1] = tmpnum;
    }
    if (NumArr.length >= 2 && NumArr[1].length == 1) NumArr[1] = "0" + NumArr[1];
    if (NumArr.length === 3 && NumArr[2].length == 1) NumArr[2] = "0" + NumArr[2];

    if (NumArr[0].length != 4 || NumArr[1].length != 2 || NumArr[2].length != 2) {
      BadCell(aCell);
      return true;
    }
    aCell.innerHTML = `${NumArr[0]}-${NumArr[1]}-${NumArr[2]}`;
    OkCell(aCell);
    return true;
  }
  if (aCell.cellIndex == NAME_COL) { // name col
    if (aCellVal === "") {
      BadCell(aCell);
    } else {
      if (aCellVal.includes(",")) {
        aCell.innerHTML = aCellVal.replace(/,/g, ';');
      }
      OkCell(aCell);
    }
    return true;
  }
  if (aCell.cellIndex == FREQ_COL) { // freq col
    if (aCellVal === "") {
      OkCell(aCell);
      return true;
    }
    const CellInt = aCellVal.match(/^[0-9]*/);
    const CellTxt = aCellVal.match(/[wWmMyYdD]$/);
    if (CellInt === "" || CellTxt === "" || CellInt + CellTxt != aCellVal) {
      BadCell(aCell);
      return true;
    }
    aCell.innerHTML = LowerVal;
    OkCell(aCell);
    return true;
  }
  if (aCell.cellIndex >= DEBIT_COL) { // debit and credit cols
    if (aCellVal !== "" && isNaN(aCellVal)) {
      BadCell(aCell);
      return true;
    }
    if (aCellVal !== "") {
      aCell.innerHTML = Number(parseFloat(aCellVal)).toFixed(2).toString();
    }
    OkCell(aCell);
    return true;
  }
}

function colorpickerChanged(aColorpicker) {
  const aRow = aColorpicker.closest("tr");
  const CellBG = aColorpicker.value;
  for (let c = 1; c < aRow.cells.length; c++) {
    aRow.cells[c].bgColor = CellBG;
  }
}

function MakeCell(aRow, numCell, innerText, Editable = "true") {
    const aCell = aRow.insertCell(numCell);
    innerText = innerText || "";

    if (numCell == GRABBER_COL) {
        aCell.innerHTML = innerText;
        aCell.className = "sorter";
        aCell.setAttribute('align', 'center');
        aCell.setAttribute('valign', 'middle');
        aCell.setAttribute('bgcolor', GRABBER_COLOR);
    } else if (numCell <= CREDIT_COL) {
        aCell.innerHTML = innerText;
        aCell.setAttribute('contenteditable', Editable);
        aCell.addEventListener("blur", ValidateCell);
        if (numCell == NAME_COL) aCell.className = "left";
        if (numCell >= DEBIT_COL) aCell.className = "right";
    } else if (numCell == COLOR_COL) {
        const containerdiv = document.createElement("div");
        containerdiv.setAttribute("class", "colorpickerContainer");
        const pendiv = document.createElement("div");
        pendiv.setAttribute("class", "colorpickerPen");
        pendiv.innerHTML = "&#128394;";
        const tooldiv = document.createElement("div");
        tooldiv.setAttribute("class", "colorpickerTool");
        const colorpicker = document.createElement("input");
        colorpicker.setAttribute("type", "color");
        colorpicker.setAttribute("class", "colorpicker");
        colorpicker.value = (innerText !== "") ? innerText : DEFAULT_ROW_COLOR;
        colorpicker.setAttribute("oninput", "colorpickerChanged(this)");
        tooldiv.appendChild(colorpicker);
        containerdiv.appendChild(pendiv);
        containerdiv.appendChild(tooldiv);
        aCell.appendChild(containerdiv);
        colorpickerChanged(colorpicker);
    } else if (numCell == DELETE_COL) {
        aCell.className = "x";
        aCell.innerHTML = "<div onclick=\"DeleteRow(this)\" class=\"x\">x</div>";
  }
}

function AddRow(LineArr) {
  LineArr = LineArr || Array(8).fill("");
  LineArr.unshift("&#9776;");
  const IOTable = document.getElementById("InOutTableBody");
  const NewRow = IOTable.insertRow(IOTable.rows.length);
  for (let x = 0; x < 9; x++) {
    MakeCell(NewRow, x, LineArr[x]);
  }
}

function SaveTable() {
  const buildData = BuildDataToSave();
  const now = new Date();
  const day = ("0" + now.getDate()).slice(-2);
  const month = ("0" + (now.getMonth() + 1)).slice(-2);
  const today = `${now.getFullYear()}-${month}-${day}`;
  const FileName = `finances-${today}.csv`;
  const a = document.createElement('a');
  a.href = 'data:application/csv;charset=utf-8,' + encodeURIComponent(buildData);
  a.target = '_blank';
  a.download = FileName;
  a.click();
}

function ClearTable(WarnText) {
  const IOTable = document.getElementById("InOutTableBody");
  if (WarnText && IOTable.hasChildNodes() && !document.getElementById('nosafe').checked) {
    if (!confirm(WarnText)) return;
  }
  while (IOTable.hasChildNodes()) {
    IOTable.removeChild(IOTable.firstChild);
  }
  ClearForecastTable();
  document.getElementById("LoadInfo").innerHTML = "";
  document.getElementById("StartDate").value = "";
  document.getElementById("EndDate").value = "";
  document.getElementById("StartBal").value = "";
}

function LoadTable(DataIn) {
  ClearTable();
  const DataLinesArr = DataIn.split(/\r\n|\n/);
  for (const line of DataLinesArr) {
    if (line !== "") {
      const DataLineArr = line.split(',');
      if (DataLineArr[2] == CSV_METADATA_MARKER) {
        document.getElementById("StartDate").value = DataLineArr[0];
        document.getElementById("EndDate").value = DataLineArr[1];
        document.getElementById("StartBal").value = DataLineArr[3];
      } else {
        AddRow(DataLineArr);
      }
    }
  }
}

function DeleteRow(DivObj) {
  if (!document.getElementById('nosafe').checked) {
    if (!confirm("Delete row: Are you sure?")) return true;
  }
  const RowIndex = DivObj.parentNode.parentNode.rowIndex;
  DivObj.closest('tbody').deleteRow(RowIndex - 1);
}

function AlertRow(InR, InRowDesc, InText) {
  alert(`Row ${InR + 1} "${InRowDesc}":\n${InText}`);
}

function BuildForecastArr() {
  ForecastArr = [];
  const table = document.getElementById("InOutTableBody");
  for (let r = 0; r < table.rows.length; r++) {
    if (table.rows[r].cells[FREQ_COL].innerHTML === "" &&
        table.rows[r].cells[START_DATE_COL].innerHTML != table.rows[r].cells[END_DATE_COL].innerHTML) {
      AlertRow(r, table.rows[r].cells[NAME_COL].innerHTML, "must have Start and End dates the same or Freq specified.");
      return false;
    }
  }

  const TStartEl = document.getElementById('StartDate');
  const TEndEl = document.getElementById('EndDate');
  const TBalEl = document.getElementById('StartBal');

  if (TStartEl.value === "") TStartEl.value = Date.today().toString('yyyy-MM-dd');
  if (TEndEl.value === "" || TEndEl.value < TStartEl.value) {
    TEndEl.value = Date.parse(TStartEl.value).addYears(1).toString('yyyy-MM-dd');
  }
  if (TBalEl.value === "" || isNaN(TBalEl.value)) TBalEl.value = 0;

  const TStart = new Date.parse(TStartEl.value);
  const TEnd = new Date.parse(TEndEl.value);

  for (let r = 0; r < table.rows.length; r++) {
    let RowStart = new Date.parse(table.rows[r].cells[START_DATE_COL].innerHTML);
    let RowEnd = new Date.parse(table.rows[r].cells[END_DATE_COL].innerHTML);
    const RowDesc = table.rows[r].cells[NAME_COL].innerHTML;
    let RowFreqN = table.rows[r].cells[FREQ_COL].innerHTML.match(/[0-9]*/);
    let RowFreqP = table.rows[r].cells[FREQ_COL].innerHTML.match(/[dDwWmMyY]/);
    const RowDebit = table.rows[r].cells[DEBIT_COL].innerHTML;
    const RowCredit = table.rows[r].cells[CREDIT_COL].innerHTML;
    const RowColor = table.rows[r].cells[COLOR_COL].getElementsByClassName('colorpicker')[0].value;

    if (!isFinite(RowStart)) {
      AlertRow(r, RowDesc, "Does not have a valid start date.");
      return false;
    }
    if (RowStart > RowEnd) {
      RowEnd = RowStart;
      table.rows[r].cells[END_DATE_COL].innerHTML = RowEnd.toString('yyyy-MM-dd');
    }
    if (RowStart > TEnd) continue;

    const StartReal = (RowStart < TStart) ? TStart : RowStart;
    const EndReal = (RowEnd !== "" && RowEnd < TEnd) ? RowEnd : TEnd;

    let RowFreqPVal = "none";
    if (RowStart.valueOf() !== RowEnd.valueOf()) {
      if (!RowFreqN || RowFreqN < 0) {
          AlertRow(r, RowDesc, "Freq amount less than 1.\nSetting to 1.");
          RowFreqN = 1;
      }
      if (RowFreqN % 1 !== 0) {
          RowFreqN = Math.round(RowFreqN);
          AlertRow(r, RowDesc, "Freq amount non-integer.\nRounded to: " + RowFreqN);
      }
      if (!RowFreqP || "dwmy".indexOf(RowFreqP[0].toLowerCase()) === -1) {
          AlertRow(r, RowDesc, "Freq type invalid or missing.\nSetting to m (month).");
          RowFreqP = ["m"];
      }
      RowFreqPVal = RowFreqP[0].toLowerCase();
      table.rows[r].cells[FREQ_COL].innerHTML = `${RowFreqN}${RowFreqPVal}`;
    }

    let ThisDate = RowStart;
    do {
      if (ThisDate.between(StartReal, EndReal)) {
        ForecastArr.push([
          ThisDate.toString('yyyy-MM-dd'), RowDesc, RowDebit, RowCredit, 0, RowColor
        ]);
      }
      if (RowFreqPVal === "none") break;
      const timewarp = 1 * RowFreqN || 1;
      if (RowFreqPVal == "d") ThisDate.addDays(timewarp);
      if (RowFreqPVal == "w") ThisDate.addWeeks(timewarp);
      if (RowFreqPVal == "m") ThisDate.addMonths(timewarp);
      if (RowFreqPVal == "y") ThisDate.addYears(timewarp);
    } while (ThisDate <= EndReal);
  }
  ForecastArr.sort((a, b) => (a[0] + a[1]).toLowerCase().localeCompare((b[0] + b[1]).toLowerCase()));
  SaveBuildData();
  return true;
}

function ClearForecastTable() {
  const ForeCastClear = document.getElementById("forecastTrack");
  while (ForeCastClear.hasChildNodes()) {
    ForeCastClear.removeChild(ForeCastClear.lastChild);
  }
  const pointers = ["lowpointer", "highpointer", "warnpointer"];
  pointers.forEach(p => {
    const pointerEl = document.getElementById(p);
    if (pointerEl) {
      pointerEl.style.left = 0;
      pointerEl.style.top = 0;
      pointerEl.style.visibility = 'hidden';
    }
  });
}

function calculateForecastMetrics(forecastArr, startBalance) {
    let balTrack = startBalance;
    let lowestBal = startBalance;
    let highestBal = startBalance;
    let lowestRow = 1;
    let highestRow = 1;
    let firstNegRow = 0;

    for (let r = 2; r < forecastArr.length; r++) {
        const debit = parseFloat(forecastArr[r][2]) || 0;
        const credit = parseFloat(forecastArr[r][3]) || 0;
        balTrack += credit - debit;
        forecastArr[r][6] = balTrack.toFixed(2);

        if (balTrack < lowestBal) {
            lowestRow = r;
            lowestBal = balTrack;
        }
        if (balTrack > highestBal) {
            highestRow = r;
            highestBal = balTrack;
        }
        if (balTrack < 0 && firstNegRow === 0) {
            firstNegRow = r;
        }
    }
    return { lowestRow, highestRow, firstNegRow };
}

function renderForecastTable(forecastArr, metrics) {
    const StatusF = document.getElementById("forecastTrack");
    const OutTable = document.createElement('table');
    const OTBody = document.createElement('tbody');
    OutTable.appendChild(OTBody);

    let lastMonth = "start things off";

    for (let r = 0; r < forecastArr.length; r++) {
        const NewRow = document.createElement('tr');
        NewRow.style.backgroundColor = forecastArr[r][5];

        for (let c = 0; c < 5; c++) {
            const NewCell = document.createElement('td');
            let myText = forecastArr[r][c];

            if (r > 0) {
                if (myText !== "" && (c === 2 || c === 3)) {
                    myText = Number(parseFloat(myText)).toFixed(2);
                }
                if (c === 4) {
                    myText = (r === 1) ? forecastArr[r][4] : forecastArr[r][6];
                }
            }
             if (r > 0 && parseFloat(forecastArr[r][6] || forecastArr[r][4]) < 0) {
                 NewCell.style.fontStyle = "italic";
            }
            NewCell.appendChild(document.createTextNode(myText));
            NewCell.className = (c < 2) ? "left" : "right";
            NewRow.appendChild(NewCell);
        }

        const curMonth = forecastArr[r][0].split("-")[1];
        if (r > 1 && curMonth !== lastMonth) {
            NewRow.className = "outbordersep";
            lastMonth = curMonth;
        } else {
            NewRow.className = "outborder";
        }
        OTBody.appendChild(NewRow);
    }

    StatusF.appendChild(OutTable);

    function applyHighlight(row, className, pointerId) {
        row.className += ` ${className}`;
        for (let c = 0; c < 5; c++) {
            row.cells[c].style.fontWeight = "bold";
        }
        const pointer = document.getElementById(pointerId);
        const posX = OutTable.offsetLeft + row.offsetLeft + row.offsetWidth + 7;
        const posY = OutTable.offsetTop + row.offsetTop + Math.round(row.offsetHeight / 2) - 7;
        pointer.style.visibility = 'visible';
        pointer.style.left = `${posX}px`;
        pointer.style.top = `${posY}px`;
    }

    const highlightedRows = new Set();
    const { lowestRow, firstNegRow, highestRow } = metrics;

    if (lowestRow > 1) {
        applyHighlight(OTBody.rows[lowestRow], "outborderlow", "lowpointer");
        highlightedRows.add(lowestRow);
    }
    if (firstNegRow > 1 && !highlightedRows.has(firstNegRow)) {
        applyHighlight(OTBody.rows[firstNegRow], "outborderwarn", "warnpointer");
        highlightedRows.add(firstNegRow);
    }
    if (highestRow > 1 && !highlightedRows.has(highestRow)) {
        applyHighlight(OTBody.rows[highestRow], "outborderhigh", "highpointer");
    }

    const ClearButton = document.createElement('button');
    ClearButton.className = "warnbutton";
    ClearButton.innerHTML = "Clear Forecast";
    ClearButton.onclick = ClearForecastTable;
    ClearButton.style.width = '160px';
    ClearButton.style.height = '44px';
    StatusF.appendChild(ClearButton);
}

function DrawForecastTable() {
    ClearForecastTable();
    const startBalance = parseFloat(document.getElementById("StartBal").value) || 0;
    ForecastArr.unshift(["", "Start Balance", "", "", startBalance.toFixed(2), HEADER_COLOR]);
    ForecastArr.unshift(["Date", "Description", "Out", "In", "Bal", HEADER_COLOR]);

    const metrics = calculateForecastMetrics(ForecastArr, startBalance);
    renderForecastTable(ForecastArr, metrics);
}

function Forecast() {
  if (BuildForecastArr()) {
    DrawForecastTable();
  }
}

window.onload = function() {
  const filesInput = document.getElementById("files");
  const LoadInfo = document.getElementById("LoadInfo");
  filesInput.addEventListener("change", event => {
      const file = event.target.files[0];
      const reader = new FileReader();
      reader.addEventListener("load", event => {
          const fileIn = event.target.result;
          if (fileIn) {
            LoadTable(fileIn);
            const nameFile = `Data Source: ${filesInput.value.replace(/.*\\/, "")}`;
            const loadTime = new Date().toString('yyyy-MM-dd HH:mm:ss');
            LoadInfo.innerHTML = `${nameFile} @ ${loadTime}`;
          }
      });
      reader.readAsText(file);
  });
  if (localStorage["ForeCastArr"]) {
      LoadBuildData();
  }
}
</script>
</head>
<body>
  <table class='starts'>
    <tr class='starts'>
      <td class='starts' rowspan='3'><button onclick="Forecast()" style="width:150;height:66">Forecast</button></td>
      <td class='starts' rowspan='3' width='2'></td>
      <td class='starts right' width='68'>Start Date:</td>
      <td class='starts'><input class="datefield" id="StartDate" type="date"></td>
    </tr>
    <tr class='starts'>
      <td class='starts right'>End Date:</td>
      <td class='starts'><input class="datefield" id="EndDate" type="date"></td>
    </tr>
    <tr class='starts'>
      <td class='starts right'>Balance:</td>
      <td class='starts'><input class="balfield" id="StartBal" type="number"></td>
    </tr>
  </table>
  <table id="InOutTable">
    <thead>
      <tr id="HeadRow">
        <th bgcolor='#A9A9A9'>&#9776;</th>
        <th>Start</th>
        <th>End</th>
        <th>Name</th>
        <th>
          <div class="tooltip">Freq<span class="tooltiptext">
        Recurrance:
<pre class='left'>
 [every][period]
 1y - every 1 years
 2m - every 2 months
 4w - every 4 weeks
14d - every 14 days
</pre>
      </span></div>
        </th>
        <th>Debit</th>
        <th>Credit</th>
        <th colspan=2>Do</th>
      </tr>
    </thead>
    <tbody id="InOutTableBody"></tbody>
  </table>

  <button onclick="AddRow()">Add Row</button><button onclick="ClearTable('Clearing table: Are you sure?')" class="warnbutton">Clear</button><label class="info"><input type="checkbox" id="nosafe" value="unchecked" class="checkbox">No confirmation</label>
  <button onclick="SaveTable()">Save</button><input type="file" id="files" accept=".csv" class="files" style='visibility: hidden; width: 0px;'><button onclick="document.getElementById('files').click();">Load</button>

  <div id="LoadInfo" class="info"></div>
  <div id="forecastTrack"></div>
  <div id="lowpointer" class="pointer lowpointer"> &larr; Minimum &larr; </div>
  <div id="highpointer" class="pointer highpointer"> &larr; Maximum &larr; </div>
  <div id="warnpointer" class="pointer warnpointer"> &larr; Warning &larr; </div>
  <p><b>** KNOWN BUGS **</b></p>
  <ol type='1'>
    <li>
      <pre class='left' style="white-space: pre-wrap;">
When using months periods (Nm) and next calculated date exceeds days in a month, the date is thereafter modified.

example: recurrance 1m on 31st hits 30 day month, then uses 30 thereafter, and again when it hits February, using 28 thereafter.

This does not affect year (y), week (w), or days (d) periods.
This is an artifact of work being performed via "add period to last date" - when Feb 31st is encountered 'addMonths' function in date.min.js returns sane date.
A fix is not immediately apparent and affects a small slice of data moving certain items up to 3 days earlier.
</pre>
    </li>
  </ol>
  <pre class='left' style="white-space: pre-wrap;">
Report bugs to rake74@hotmail.com
</pre>
  <script src="RowSorter/RowSorter.js"></script>
  <script>
    RowSorter("#InOutTable", {
      handler: 'td.sorter',
      dragClass: 'sorting-row'
    });
  </script>
</body>
</html>
