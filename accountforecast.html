<html>
<head>
<title>Account Forecast (&beta;)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type='text/css'>
body, table, td, select, input, p, li
{
  font-size: 10px;
  font-family: "Lucida Console", Monaco, monospace;
}

button, input
{
  width: 83px;
  height: 22px;
  text-align: center;
}

.checkbox
{
  width: 12px;
  height: 12px;
  vertical-align: middle;
}

table
{
  border-collapse: collapse;
}

.starts
{
  border: 0;
  padding: 0;
}

table, td, th
{
  border: 1px solid black;
}

td
{
  padding: 1px;
  text-align: center;
  vertical-align: middle;
}

.left
{
  text-align: left;
}

.right
{
  text-align: right;
}

th
{
  background-color: #BBB;
}

ul
{
  list-style: square;
  margin-left: 0;
  padding-left: 20px;
}

li ul
{
  margin-left: 0;
}

.grabber
{
  text-align: center;
  vertical-align: middle;
}

.colorpicker
{
  opacity: 0;
  width: 14px;
  height: 14px;
  cursor: cell;
}

.colorpicker::-webkit-appearance
{
  border: none;
}

.colorpicker::-webkit-color-swatch-wrapper
{
  padding: 0;
}

.colorpicker::-webkit-color-swatch
{
  border: none;
}

.x
{
  border-color: #999999;
  background-color: darkred;
  border-width: 1;
  font-weight: 900;
  color: white;
  width: 12px;
  height: 12px;
  text-align: center;
  vertical-align: middle;
  cursor: pointer;
  display: inline-block;
}

.info
{
  color: #333333;
  font-size: 10px;
}

.loadlabel
{
  width: 83;
  text-align: center;
  vertical-align: middle;
  display: inline-block;
}

.datefield
{
  width: 123px;
}

.balfield
{
  width: 123px;
}

.warnbutton
{
  background-color: #FF5555;
}

.outborder
{
  border-top: thin solid black;
  border-bottom: thin solid black;
  border-left: thin solid black;
  border-right: thin solid black;
}

.outbordersep
{
  border-top: thick solid black;
  border-bottom: thin solid black;
  border-left: thin solid black;
  border-right: thin solid black;
}

.outborderlow
{
  background-color: #ffcccc; /* semi-light red */
  border: 2px dashed red !important;
}
.outborderhigh
{
  background-color: #ccffcc; /* semi-light green */
  border: 2px dashed #00cc00 !important; /* bright green */
}
.outborderwarn
{
  background-color: #ffffcc; /* yellow */
  border: 2px dashed red !important;
}

.pointer
{
  position: absolute;
  height: 10px;
  font-size: 10px;
  font-weight: bold;
  text-align: center;
  width: 85px;
  visibility: hidden;
  z-index: 10;
}

.lowpointer
{
  border: 1px dashed red;
  background-color: #ffcccc; /* semi-light red */
}
.highpointer
{
    border: 1px dashed #00cc00; /* bright green */
    background-color: #ccffcc; /* semi-light green */
}
.warnpointer
{
    border: 1px dashed red;
    background-color: #ffffcc; /* yellow */
}

.sorter
{
  cursor: grab;
  width: 14px;
}

.sorting-row {
  opacity: 0.8;
  background-color: #fdfdfd;
}

.colorpickerContainer
{
  position: relative;
  width: 14px;
  height: 14px;
}

.colorpickerPen, .colorpickerTool
{
  width: 14px;
  height: 14px;
  position: absolute;
  top: 0;
  left: 0;
  font-weight: 900;
}

.colorpickerTool
{
  z-index: 10;
}
</style>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/datejs/1.0/date.min.js"></script>
<script type="text/javascript">
'use strict';

// --- Constants for Readability and Maintenance ---
const GRABBER_COL = 0;
const START_DATE_COL = 1;
const END_DATE_COL = 2;
const NAME_COL = 3;
const FREQ_COL = 4;
const DEBIT_COL = 5;
const CREDIT_COL = 6;
const COLOR_COL = 7;
const DELETE_COL = 8;
const CSV_METADATA_MARKER = "DEFINE-STARTS";
const DEFAULT_ROW_COLOR = "#F5F5F5";
const HEADER_COLOR = "#BBBBBB";
const GRABBER_COLOR = "#A9A9A9";

let ForecastArr = [];

function BadCell(aCell) {
  aCell.bgColor = "#FFCC00";
}

function OkCell(aCell) {
  aCell.bgColor = aCell.parentNode.cells[COLOR_COL].getElementsByClassName('colorpicker')[0].value;
}

function removeTags(html) {
  const tagBody = '(?:[^"\'>]|"[^"]*"|\'[^\']*\')*';
  const tagOrComment = new RegExp('<(?:' + '!--(?:(?:-*[^->])*--+|-?)' + '|script\\b' + tagBody + '>[\\s\\S]*?</script\\s*' + '|style\\b' + tagBody + '>[\\s\\S]*?</style\\s*' + '|/?[a-z]' + tagBody + ')>', 'gi');
  let oldHtml;
  do {
    oldHtml = html;
    html = html.replace(tagOrComment, '');
  } while (html !== oldHtml);
  return html.replace(/</g, '&lt;');
}

function BuildDataToSave() {
  const table = document.getElementById("InOutTableBody");
  let buildData = "";
  for (let r = 0; r < table.rows.length; r++) {
    for (let c = 1; c < 8; c++) {
      if (table.rows[0].cells[c].cellIndex < COLOR_COL) {
        buildData = buildData + table.rows[r].cells[c].innerHTML + ",";
      } else {
        buildData = buildData + table.rows[r].cells[c].getElementsByClassName('colorpicker')[0].value + "\r\n";
      }
    }
  }
  buildData = buildData + document.getElementById("StartDate").value + ",";
  buildData = buildData + document.getElementById("EndDate").value + `,${CSV_METADATA_MARKER},`;
  buildData = buildData + document.getElementById("StartBal").value + "\r\n";
  return buildData;
}

function SaveBuildData() {
  const buildData = BuildDataToSave();
  localStorage["ForeCastArr"] = JSON.stringify(buildData);
}

function LoadBuildData() {
  const cArr = JSON.parse(localStorage["ForeCastArr"]);
  LoadTable(cArr);
  const LoadTime = new Date().toString('yyyy-MM-dd HH:mm:ss');
  LoadInfo.innerHTML = "Data Source: (browser storage) @ " + LoadTime;
}

function ValidateCell(e) {
  const aCell = e.target || window.event.srcElement;
  const aCellValRaw = aCell.innerHTML;
  const aCellVal = removeTags(aCellValRaw);
  aCell.innerHTML = aCellVal;
  const LowerVal = aCellVal.toLowerCase() || "";

  if (aCell.cellIndex <= END_DATE_COL) { // start and end cols
    if (aCell.cellIndex == END_DATE_COL) {
      if (LowerVal == "none" || LowerVal === "") {
        aCell.innerHTML = "none";
        OkCell(aCell);
        return true;
      }
    }
    const NumArr = aCellVal.match(/\d+\.?\d*/g);
    if (NumArr === null || NumArr.length > 3) {
      BadCell(aCell);
      return true;
    }
    if (NumArr.length == 2) {
      if (NumArr[0].length < 3 && NumArr[1].length < 3) {
        NumArr[2] = NumArr[1];
        NumArr[1] = NumArr[0];
        NumArr[0] = Date.today().toString('yyyy-MM-dd');
      } else {
        BadCell(aCell);
        return true;
      }
    }
    if (NumArr.length === 3 && NumArr[2].length == 4) {
      let tmpnum = NumArr[0];
      NumArr[0] = NumArr[2];
      NumArr[2] = NumArr[1];
      NumArr[1] = tmpnum;
    }
    if (NumArr.length >= 2 && NumArr[1].length == 1) NumArr[1] = "0" + NumArr[1];
    if (NumArr.length === 3 && NumArr[2].length == 1) NumArr[2] = "0" + NumArr[2];

    if (NumArr[0].length != 4 || NumArr[1].length != 2 || NumArr[2].length != 2) {
      BadCell(aCell);
      return true;
    }
    aCell.innerHTML = `${NumArr[0]}-${NumArr[1]}-${NumArr[2]}`;
    OkCell(aCell);
    return true;
  }
  if (aCell.cellIndex == NAME_COL) { // name col
    if (aCellVal === "") {
      BadCell(aCell);
    } else {
      if (aCellVal.includes(",")) {
        aCell.innerHTML = aCellVal.replace(/,/g, ';');
      }
      OkCell(aCell);
    }
    return true;
  }
  if (aCell.cellIndex == FREQ_COL) { // freq col
    if (aCellVal === "") {
      OkCell(aCell);
      return true;
    }
    const CellInt = aCellVal.match(/^[0-9]*/);
    const CellTxt = aCellVal.match(/[wWmMyYdD]$/);
    if (CellInt === "" || CellTxt === "" || CellInt + CellTxt != aCellVal) {
      BadCell(aCell);
      return true;
    }
    aCell.innerHTML = LowerVal;
    OkCell(aCell);
    return true;
  }
  if (aCell.cellIndex >= DEBIT_COL) { // debit and credit cols
    if (aCellVal !== "" && isNaN(aCellVal)) {
      BadCell(aCell);
      return true;
    }
    if (aCellVal !== "") {
      aCell.innerHTML = Number(parseFloat(aCellVal)).toFixed(2).toString();
    }
    OkCell(aCell);
    return true;
  }
}

function colorpickerChanged(aColorpicker) {
  const aRow = aColorpicker.closest("tr");
  const CellBG = aColorpicker.value;
  for (let c = 1; c < aRow.cells.length; c++) {
    aRow.cells[c].bgColor = CellBG;
  }
}

function MakeCell(aRow, numCell, innerText, Editable = "true") {
    const aCell = aRow.insertCell(numCell);
    innerText = innerText || "";

    if (numCell == GRABBER_COL) {
        aCell.innerHTML = innerText;
        aCell.className = "sorter";
        aCell.setAttribute('align', 'center');
        aCell.setAttribute('valign', 'middle');
        aCell.setAttribute('bgcolor', GRABBER_COLOR);
    } else if (numCell <= CREDIT_COL) {
        aCell.innerHTML = innerText;
        aCell.setAttribute('contenteditable', Editable);
        aCell.addEventListener("blur", ValidateCell);
        if (numCell == NAME_COL) aCell.className = "left";
        if (numCell >= DEBIT_COL) aCell.className = "right";
    } else if (numCell == COLOR_COL) {
        const containerdiv = document.createElement("div");
        containerdiv.setAttribute("class", "colorpickerContainer");
        const pendiv = document.createElement("div");
        pendiv.setAttribute("class", "colorpickerPen");
        pendiv.innerHTML = "&#128394;";
        const tooldiv = document.createElement("div");
        tooldiv.setAttribute("class", "colorpickerTool");
        const colorpicker = document.createElement("input");
        colorpicker.setAttribute("type", "color");
        colorpicker.setAttribute("class", "colorpicker");
        colorpicker.value = (innerText !== "") ? innerText : DEFAULT_ROW_COLOR;
        colorpicker.setAttribute("oninput", "colorpickerChanged(this)");
        tooldiv.appendChild(colorpicker);
        containerdiv.appendChild(pendiv);
        containerdiv.appendChild(tooldiv);
        aCell.appendChild(containerdiv);
        colorpickerChanged(colorpicker);
    } else if (numCell == DELETE_COL) {
        aCell.className = "x";
        aCell.innerHTML = "<div onclick=\"DeleteRow(this)\" class=\"x\">x</div>";
  }
}

function AddRow(LineArr) {
  LineArr = LineArr || Array(8).fill("");
  LineArr.unshift("&#9776;");
  const IOTable = document.getElementById("InOutTableBody");
  const NewRow = IOTable.insertRow(IOTable.rows.length);
  for (let x = 0; x < 9; x++) {
    MakeCell(NewRow, x, LineArr[x]);
  }
}

function SaveTable() {
  const buildData = BuildDataToSave();
  const now = new Date();
  const day = ("0" + now.getDate()).slice(-2);
  const month = ("0" + (now.getMonth() + 1)).slice(-2);
  const today = `${now.getFullYear()}-${month}-${day}`;
  const FileName = `finances-${today}.csv`;
  const a = document.createElement('a');
  a.href = 'data:application/csv;charset=utf-8,' + encodeURIComponent(buildData);
  a.target = '_blank';
  a.download = FileName;
  a.click();
}

function ClearTable(WarnText) {
  const IOTable = document.getElementById("InOutTableBody");
  if (WarnText && IOTable.hasChildNodes() && !document.getElementById('nosafe').checked) {
    if (!confirm(WarnText)) return;
  }
  while (IOTable.hasChildNodes()) {
    IOTable.removeChild(IOTable.firstChild);
  }
  ClearForecastTable();
  document.getElementById("LoadInfo").innerHTML = "";
  document.getElementById("StartDate").value = "";
  document.getElementById("EndDate").value = "";
  document.getElementById("StartBal").value = "";
}

function LoadTable(DataIn) {
  ClearTable();
  const DataLinesArr = DataIn.split(/\r\n|\n/);
  for (const line of DataLinesArr) {
    if (line !== "") {
      const DataLineArr = line.split(',');
      if (DataLineArr[2] == CSV_METADATA_MARKER) {
        document.getElementById("StartDate").value = DataLineArr[0];
        document.getElementById("EndDate").value = DataLineArr[1];
        document.getElementById("StartBal").value = DataLineArr[3];
      } else {
        AddRow(DataLineArr);
      }
    }
  }
}

function DeleteRow(DivObj) {
  if (!document.getElementById('nosafe').checked) {
    if (!confirm("Delete row: Are you sure?")) return true;
  }
  const RowIndex = DivObj.parentNode.parentNode.rowIndex;
  DivObj.closest('tbody').deleteRow(RowIndex - 1);
}

function AlertRow(InR, InRowDesc, InText) {
  alert(`Row ${InR + 1} "${InRowDesc}":\n${InText}`);
}

function BuildForecastArr() {
  ForecastArr = [];
  const table = document.getElementById("InOutTableBody");
  for (let r = 0; r < table.rows.length; r++) {
    if (table.rows[r].cells[FREQ_COL].innerHTML === "" &&
        table.rows[r].cells[START_DATE_COL].innerHTML != table.rows[r].cells[END_DATE_COL].innerHTML) {
      AlertRow(r, table.rows[r].cells[NAME_COL].innerHTML, "must have Start and End dates the same or Freq specified.");
      return false;
    }
  }

  const TStartEl = document.getElementById('StartDate');
  const TEndEl = document.getElementById('EndDate');
  const TBalEl = document.getElementById('StartBal');

  if (TStartEl.value === "") TStartEl.value = Date.today().toString('yyyy-MM-dd');
  if (TEndEl.value === "" || TEndEl.value < TStartEl.value) {
    TEndEl.value = Date.parse(TStartEl.value).addYears(1).toString('yyyy-MM-dd');
  }
  if (TBalEl.value === "" || isNaN(TBalEl.value)) TBalEl.value = 0;

  const TStart = new Date.parse(TStartEl.value);
  const TEnd = new Date.parse(TEndEl.value);

  for (let r = 0; r < table.rows.length; r++) {
    const RowStart = new Date.parse(table.rows[r].cells[START_DATE_COL].innerHTML);
    let RowEnd = new Date.parse(table.rows[r].cells[END_DATE_COL].innerHTML);
    const RowDesc = table.rows[r].cells[NAME_COL].innerHTML;
    let RowFreqN = table.rows[r].cells[FREQ_COL].innerHTML.match(/[0-9]*/);
    let RowFreqP = table.rows[r].cells[FREQ_COL].innerHTML.match(/[dDwWmMyY]/);
    const RowDebit = table.rows[r].cells[DEBIT_COL].innerHTML;
    const RowCredit = table.rows[r].cells[CREDIT_COL].innerHTML;
    const RowColor = table.rows[r].cells[COLOR_COL].getElementsByClassName('colorpicker')[0].value;

    if (!isFinite(RowStart)) {
      AlertRow(r, RowDesc, "Does not have a valid start date.");
      return false;
    }
    if (RowStart > RowEnd) {
      RowEnd = RowStart;
      table.rows[r].cells[END_DATE_COL].innerHTML = RowEnd.toString('yyyy-MM-dd');
    }
    if (RowStart > TEnd) continue;

    const StartReal = (RowStart < TStart) ? TStart : RowStart;
    const EndReal = (RowEnd && isFinite(RowEnd) && RowEnd < TEnd) ? RowEnd : TEnd;

    let RowFreqPVal = "none";
    if (RowStart.valueOf() !== RowEnd.valueOf()) {
      if (!RowFreqN || RowFreqN < 1) {
          AlertRow(r, RowDesc, "Freq amount less than 1.\nSetting to 1.");
          RowFreqN = 1;
      }
      if (RowFreqN % 1 !== 0) {
          RowFreqN = Math.round(RowFreqN);
          AlertRow(r, RowDesc, `Freq amount non-integer.\nRounded to: ${RowFreqN}`);
      }
      if (!RowFreqP || "dwmy".indexOf(RowFreqP[0].toLowerCase()) === -1) {
          AlertRow(r, RowDesc, "Freq type invalid or missing.\nSetting to m (month).");
          RowFreqP = ["m"];
      }
      RowFreqPVal = RowFreqP[0].toLowerCase();
      table.rows[r].cells[FREQ_COL].innerHTML = `${RowFreqN}${RowFreqPVal}`;
    }

    if (RowFreqPVal === "none") {
      if (RowStart.between(StartReal, EndReal)) {
        ForecastArr.push([RowStart.toString('yyyy-MM-dd'), RowDesc, RowDebit, RowCredit, 0, RowColor]);
      }
    } else {
      for (let i = 0; ; i++) {
        const nextDate = new Date(RowStart);
        const timewarp = i * (RowFreqN || 1);

        if (RowFreqPVal == "d") nextDate.addDays(timewarp);
        else if (RowFreqPVal == "w") nextDate.addWeeks(timewarp);
        else if (RowFreqPVal == "m") nextDate.addMonths(timewarp);
        else if (RowFreqPVal == "y") nextDate.addYears(timewarp);

        if (nextDate > EndReal) break;

        if (nextDate.between(StartReal, EndReal)) {
            ForecastArr.push([nextDate.toString('yyyy-MM-dd'), RowDesc, RowDebit, RowCredit, 0, RowColor]);
        }
      }
    }
  }
  ForecastArr.sort((a, b) => (a[0] + a[1]).toLowerCase().localeCompare((b[0] + b[1]).toLowerCase()));
  SaveBuildData();
  return true;
}

function ClearForecastTable() {
  const ForeCastClear = document.getElementById("forecastTrack");
  while (ForeCastClear.hasChildNodes()) {
    ForeCastClear.removeChild(ForeCastClear.lastChild);
  }
  const pointers = ["lowpointer", "highpointer", "warnpointer"];
  pointers.forEach(p => {
    const pointerEl = document.getElementById(p);
    if (pointerEl) {
      pointerEl.style.left = 0;
      pointerEl.style.top = 0;
      pointerEl.style.visibility = 'hidden';
    }
  });
}

function calculateForecastMetrics(forecastArr, startBalance) {
    let balTrack = startBalance;
    let lowestBal = startBalance;
    let highestBal = startBalance;
    let lowestRow = 1;
    let highestRow = 1;
    let firstNegRow = 0;

    for (let r = 2; r < forecastArr.length; r++) {
        const debit = parseFloat(forecastArr[r][2]) || 0;
        const credit = parseFloat(forecastArr[r][3]) || 0;
        balTrack += credit - debit;
        forecastArr[r][6] = balTrack.toFixed(2);

        if (balTrack < lowestBal) {
            lowestRow = r;
            lowestBal = balTrack;
        }
        if (balTrack > highestBal) {
            highestRow = r;
            highestBal = balTrack;
        }
        if (balTrack < 0 && firstNegRow === 0) {
            firstNegRow = r;
        }
    }
    return { lowestRow, highestRow, firstNegRow };
}

function renderForecastTable(forecastArr, metrics) {
    const StatusF = document.getElementById("forecastTrack");
    const OutTable = document.createElement('table');
    const OTBody = document.createElement('tbody');
    OutTable.appendChild(OTBody);

    let lastMonth = "start things off";

    for (let r = 0; r < forecastArr.length; r++) {
        const NewRow = document.createElement('tr');
        NewRow.style.backgroundColor = forecastArr[r][5];

        for (let c = 0; c < 5; c++) {
            const NewCell = document.createElement('td');
            let myText = forecastArr[r][c];

            if (r > 0) {
                if (myText !== "" && (c === 2 || c === 3)) {
                    myText = Number(parseFloat(myText)).toFixed(2);
                }
                if (c === 4) {
                    myText = (r === 1) ? forecastArr[r][4] : forecastArr[r][6];
                }
            }
             if (r > 0 && parseFloat(forecastArr[r][6] || forecastArr[r][4]) < 0) {
                 NewCell.style.fontStyle = "italic";
            }
            NewCell.appendChild(document.createTextNode(myText));
            NewCell.className = (c < 2) ? "left" : "right";
            NewRow.appendChild(NewCell);
        }

        const curMonth = forecastArr[r][0].split("-")[1];
        if (r > 1 && curMonth !== lastMonth) {
            NewRow.className = "outbordersep";
            lastMonth = curMonth;
        } else {
            NewRow.className = "outborder";
        }
        OTBody.appendChild(NewRow);
    }

    StatusF.appendChild(OutTable);

    function applyHighlight(row, className, pointerId) {
        row.className += ` ${className}`;
        for (let c = 0; c < 5; c++) {
            row.cells[c].style.fontWeight = "bold";
        }
        const pointer = document.getElementById(pointerId);
        const posX = OutTable.offsetLeft + row.offsetLeft + row.offsetWidth + 7;
        const posY = OutTable.offsetTop + row.offsetTop + Math.round(row.offsetHeight / 2) - 7;
        pointer.style.visibility = 'visible';
        pointer.style.left = `${posX}px`;
        pointer.style.top = `${posY}px`;
    }

    const highlightedRows = new Set();
    const { lowestRow, firstNegRow, highestRow } = metrics;

    if (lowestRow > 1) {
        applyHighlight(OTBody.rows[lowestRow], "outborderlow", "lowpointer");
        highlightedRows.add(lowestRow);
    }
    if (firstNegRow > 1 && !highlightedRows.has(firstNegRow)) {
        applyHighlight(OTBody.rows[firstNegRow], "outborderwarn", "warnpointer");
        highlightedRows.add(firstNegRow);
    }
    if (highestRow > 1 && !highlightedRows.has(highestRow)) {
        applyHighlight(OTBody.rows[highestRow], "outborderhigh", "highpointer");
    }

    const ClearButton = document.createElement('button');
    ClearButton.className = "warnbutton";
    ClearButton.innerHTML = "Clear Forecast";
    ClearButton.onclick = ClearForecastTable;
    ClearButton.style.width = '160px';
    ClearButton.style.height = '44px';
    StatusF.appendChild(ClearButton);
}

function DrawForecastTable() {
    ClearForecastTable();
    const startBalance = parseFloat(document.getElementById("StartBal").value) || 0;
    ForecastArr.unshift(["", "Start Balance", "", "", startBalance.toFixed(2), HEADER_COLOR]);
    ForecastArr.unshift(["Date", "Description", "Out", "In", "Bal", HEADER_COLOR]);

    const metrics = calculateForecastMetrics(ForecastArr, startBalance);
    renderForecastTable(ForecastArr, metrics);
}

function Forecast() {
  if (BuildForecastArr()) {
    DrawForecastTable();
  }
}

window.onload = function() {
  const filesInput = document.getElementById("files");
  const LoadInfo = document.getElementById("LoadInfo");
  filesInput.addEventListener("change", event => {
      const file = event.target.files[0];
      const reader = new FileReader();
      reader.addEventListener("load", event => {
          const fileIn = event.target.result;
          if (fileIn) {
            LoadTable(fileIn);
            const nameFile = `Data Source: ${filesInput.value.replace(/.*\\/, "")}`;
            const loadTime = new Date().toString('yyyy-MM-dd HH:mm:ss');
            LoadInfo.innerHTML = `${nameFile} @ ${loadTime}`;
          }
      });
      reader.readAsText(file);
  });
  if (localStorage["ForeCastArr"]) {
      LoadBuildData();
  }
}
</script>
</head>
<body>
  <table class='starts'>
    <tr class='starts'>
      <td class='starts' rowspan='3'><button onclick="Forecast()" style="width:150;height:66">Forecast</button></td>
      <td class='starts' rowspan='3' width='2'></td>
      <td class='starts right' width='68'>Start Date:</td>
      <td class='starts'><input class="datefield" id="StartDate" type="date"></td>
    </tr>
    <tr class='starts'>
      <td class='starts right'>End Date:</td>
      <td class='starts'><input class="datefield" id="EndDate" type="date"></td>
    </tr>
    <tr class='starts'>
      <td class='starts right'>Balance:</td>
      <td class='starts'><input class="balfield" id="StartBal" type="number"></td>
    </tr>
  </table>
  <table id="InOutTable">
    <thead>
      <tr id="HeadRow">
        <th bgcolor='#A9A9A9'>&#9776;</th>
        <th>Start</th>
        <th>End</th>
        <th>Name</th>
        <th>Freq</th>
        <th>Debit</th>
        <th>Credit</th>
        <th colspan=2>Do</th>
      </tr>
    </thead>
    <tbody id="InOutTableBody"></tbody>
  </table>

  <button onclick="AddRow()">Add Row</button><button onclick="ClearTable('Clearing table: Are you sure?')" class="warnbutton">Clear</button><label class="info"><input type="checkbox" id="nosafe" value="unchecked" class="checkbox">No confirmation</label>
  <button onclick="SaveTable()">Save</button><input type="file" id="files" accept=".csv" class="files" style='visibility: hidden; width: 0px;'><button onclick="document.getElementById('files').click();">Load</button>

  <div id="LoadInfo" class="info"></div>
  <div id="forecastTrack"></div>
  <div id="lowpointer" class="pointer lowpointer"> &larr; Minimum &larr; </div>
  <div id="highpointer" class="pointer highpointer"> &larr; Maximum &larr; </div>
  <div id="warnpointer" class="pointer warnpointer"> &larr; Warning &larr; </div>

  <hr>
  <details>
    <summary>Help / Formatting Guide</summary>
    <div style="padding: 10px;">
        <h4>Date Columns (Start / End)</h4>
        <ul>
            <li>Dates in the main table must be entered in <b>YYYY-MM-DD</b> format.</li>
            <li>The 'End' date column can also accept the value '<b>none</b>'.</li>
            <li><b>Note:</b> The main "Start Date" and "End Date" fields at the top of the page may display in a different format (e.g., MM/DD/YYYY) based on your browser or system settings. This is normal.</li>
        </ul>
        <h4>Freq (Frequency) Column</h4>
        <ul>
            <li>Frequency is specified as a number followed by a time period character. Examples:</li>
            <ul style="list-style: none;">
                <li><code>1y</code> - every 1 year</li>
                <li><code>2m</code> - every 2 months</li>
                <li><code>4w</code> - every 4 weeks</li>
                <li><code>14d</code> - every 14 days</li>
            </ul>
        </ul>
    </div>
  </details>
  <hr>

  <pre class='left' style="white-space: pre-wrap;">
Report bugs to rake74@hotmail.com
</pre>

  <script>
  /*
    The MIT License (MIT)
    Copyright (c) 2014 GÃ¶khan Bora
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

    Notes from rake74:
    Repo: https://github.com/arteyazilim/rowsorter
    Referenced/found via https://www.jqueryscript.net/table/touch-table-row-sorter.html
  */
  (function(root, factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define('RowSorter', factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else {
        root.RowSorter = factory();
    }
  })(this, function() {
    'use strict';
    var $ = window.jQuery||false, arrProto = Array.prototype, touchSupport = !!('ontouchstart' in document), helperAttrName = 'data-rowsorter', defaults = { handler: null, tbody: true, tableClass: 'sorting-table', dragClass: 'sorting-row', stickTopRows: 0, stickBottomRows: 0, onDragStart: null, onDragEnd: null, onDrop: null };
    function RowSorter(table, opts) {
        if (!(this instanceof RowSorter)) { return new RowSorter(table, opts); }
        if (typeof table === 'string') { table = findTable(table); }
        if (is(table, 'table') === false) { throw new Error('Table not found.'); }
        if (table[ helperAttrName ] instanceof RowSorter) { return table[ helperAttrName ]; }
        this._options = extend(defaults, opts); this._table = table; this._tbody = table; this._rows = []; this._lastY = false; this._draggingRow = null; this._firstTouch = true; this._lastSort = null; this._ended = true;
        this._mousedown = bind(mousedown, this); this._mousemove = bind(mousemove, this); this._mouseup = bind(mouseup, this);
        this._touchstart = bind(touchstart, this); this._touchmove = bind(touchmove, this); this._touchend = bind(touchend, this); this._touchId = null;
        this._table[ helperAttrName ] = this; this.init();
    }
    RowSorter.prototype.init = function() {
        if (this._options.tbody) { var bodies = this._table.getElementsByTagName('tbody'); if (bodies.length > 0) { this._tbody = bodies[0]; } }
        if (typeof this._options.onDragStart !== 'function') { this._options.onDragStart = null; }
        if (typeof this._options.onDrop !== 'function') { this._options.onDrop = null; }
        if (typeof this._options.onDragEnd !== 'function') { this._options.onDragEnd = null; }
        if (typeof this._options.stickTopRows !== 'number' || this._options.stickTopRows < 0) { this._options.stickTopRows = 0; }
        if (typeof this._options.stickBottomRows !== 'number' || this._options.stickBottomRows < 0) { this._options.stickBottomRows = 0; }
        addEvent(this._table, 'mousedown', this._mousedown); addEvent(document, 'mouseup', this._mouseup);
        if (touchSupport) { addEvent(this._table, 'touchstart', this._touchstart); addEvent(this._table, 'touchend', this._touchend); }
        if ('onselectstart' in document) { var that = this; addEvent(document, 'selectstart', function(e) { var ev = e||window.event; if (that._draggingRow !== null) { if (ev.preventDefault) { ev.preventDefault(); } else { ev.returnValue = false; } return false; } }); }
    };
    function mousedown(ev) { ev = ev || window.event; if (this._start(ev.target || ev.srcElement, ev.clientY)) { if (ev.preventDefault) { ev.preventDefault(); } else { ev.returnValue = false; } return false; } return true; }
    function touchstart(ev) { if (ev.touches.length === 1) { var touch = ev.touches[0], target = document.elementFromPoint(touch.clientX, touch.clientY); this._touchId = touch.identifier; if (this._start(target, touch.clientY)) { if (ev.preventDefault) { ev.preventDefault(); } else { ev.returnValue = false; } return false; } } return true; }
    RowSorter.prototype._start = function(target, clientY) {
        if (this._draggingRow) { this._end(); }
        this._rows = this._tbody.rows; if (this._rows.length < 2) { return false; }
        if (this._options.handler) { var handlers = qsa(this._table, this._options.handler); if (!handlers || inArray(handlers, target) === -1) { return false; } }
        var draggingRow = closest(target, 'tr'); var current_index = rowIndex(this._tbody, draggingRow);
        if (current_index === -1 || (this._options.stickTopRows > 0 && current_index < this._options.stickTopRows) || (this._options.stickBottomRows > 0 && current_index >= this._rows.length - this._options.stickBottomRows) ) { return false; }
        this._draggingRow = draggingRow;
        if (this._options.tableClass) { addClass(this._table, this._options.tableClass); }
        if (this._options.dragClass) { addClass(this._draggingRow, this._options.dragClass); }
        this._oldIndex = current_index;
        if (this._options.onDragStart) { this._options.onDragStart(this._tbody, this._draggingRow, this._oldIndex); }
        this._lastY = clientY; this._ended = false;
        addEvent(this._table, 'mousemove', this._mousemove);
        if (touchSupport) { addEvent(this._table, 'touchmove', this._touchmove); }
        return true;
    };
    function mousemove(ev) { ev = ev || window.event; this._move(ev.target || ev.srcElement, ev.clientY); return true; }
    function touchmove(ev) { if (ev.touches.length === 1) { var touch = ev.touches[0], target = document.elementFromPoint(touch.clientX, touch.clientY); if (this._touchId === touch.identifier) { this._move(target, touch.clientY); } } return true; }
    RowSorter.prototype._move = function(target, clientY) {
        if (!this._draggingRow) { return; }
        var direction = clientY > this._lastY ? 1 : (clientY < this._lastY ? -1 : 0);
        if (direction !== 0) {
            var hoveredRow = closest(target, 'tr');
            if (hoveredRow && hoveredRow !== this._draggingRow && inArray(this._rows, hoveredRow) !== -1) {
                var move = true; if (this._options.stickTopRows > 0 || this._options.stickBottomRows > 0) { var new_index = rowIndex(this._tbody, hoveredRow); if ((this._options.stickTopRows > 0 && new_index < this._options.stickTopRows) || (this._options.stickBottomRows > 0 && new_index >= this._rows.length - this._options.stickBottomRows) ) { move = false; } }
                if (move) { moveRow(this._draggingRow, hoveredRow, direction); }
                this._lastY = clientY;
            }
        }
    };
    function mouseup() { this._end(); }
    function touchend(ev) { if (ev.changedTouches.length > 0 && this._touchId === ev.changedTouches[0].identifier) { this._end(); } }
    RowSorter.prototype._end = function() {
        if (!this._draggingRow) { return true; }
        if (this._options.tableClass) { removeClass(this._table, this._options.tableClass); }
        if (this._options.dragClass) { removeClass(this._draggingRow, this._options.dragClass); }
        var new_index = rowIndex(this._tbody, this._draggingRow);
        if (new_index !== this._oldIndex) {
            var previous = this._lastSort; this._lastSort = { previous: previous, newIndex: new_index, oldIndex: this._oldIndex };
            if (this._options.onDrop) { this._options.onDrop(this._tbody, this._draggingRow, new_index, this._oldIndex); }
        } else if (this._options.onDragEnd) { this._options.onDragEnd(this._tbody, this._draggingRow, this._oldIndex); }
        this._draggingRow = null; this._lastY = false; this._touchId = null; this._ended = true;
        removeEvent(this._table, 'mousemove', this._mousemove);
        if (touchSupport) { removeEvent(this._table, 'touchmove', this._touchmove); }
    };
    RowSorter.prototype.revert = function() { if (this._lastSort !== null) { var lastSort = this._lastSort, old_index = lastSort.oldIndex, new_index = lastSort.newIndex, rows = this._tbody.rows, max_index = rows.length - 1; if (rows.length > 1) { if (old_index < max_index) { this._tbody.insertBefore(rows[ new_index ], rows[ old_index + (new_index > old_index ? 0 : 1) ]); } else { this._tbody.appendChild(rows[ new_index ]); } } this._lastSort = lastSort.previous; } };
    RowSorter.prototype.undo = RowSorter.prototype.revert;
    RowSorter.prototype.destroy = function() { this._table[ helperAttrName ] = null; if (this._ended === false) { this._end(); } removeEvent(this._table, 'mousedown', this._mousedown); removeEvent(document, 'mouseup', this._mouseup); if (touchSupport) { removeEvent(this._table, 'touchstart', this._touchstart); removeEvent(this._table, 'touchend', this._touchend); } };
    function getSorterObject(table) { if (table instanceof RowSorter) { return table; } if (typeof table === 'string') { table = findTable(table); } if (is(table, 'table') && helperAttrName in table && table[ helperAttrName ] instanceof RowSorter) { return table[ helperAttrName ]; } return null; }
    function findTable(query) { var elements = qsa(document, query); if (elements.length > 0 && is(elements[0], 'table')) { return elements[0]; } return null; }
    function is(obj, tag) { return obj && typeof obj === 'object' && 'nodeName' in obj && obj.nodeName === tag.toUpperCase(); }
    function moveRow(row, reference, direction) { var parent = row.parentNode; if (direction === 1) { if (reference.nextSibling) { parent.insertBefore(row, reference.nextSibling); } else { parent.appendChild(row); } } else if (direction === -1) { parent.insertBefore(row, reference); } }
    function rowIndex(tbody, row) { var rows = tbody.rows, length = rows.length, i = 0; for (; i < length; i++) { if (row === rows[ i ]) { return i; } } return -1; }
    function addEvent(obj, type, fn) { if (obj.attachEvent) { obj.attachEvent('on' + type, fn); } else { obj.addEventListener(type, fn, false); } }
    function removeEvent(obj, type, fn) { if (obj.detachEvent) { obj.detachEvent('on' + type, fn); } else { obj.removeEventListener(type, fn, false); } }
    function trim(str) { return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ''); }
    function hasClass(element, cls) {
        cls = trim(cls); if (cls === '') { return false; }
        if (cls.indexOf(' ') !== -1) { var classes = cls.replace(/\s+/g, ' ').split(' '), i = 0, len = classes.length; for (; i < len; i++) { if (hasClass(element, classes[ i ]) === false) { return false; } } return true; }
        if (element.classList) { return !!element.classList.contains(cls); } else { return !!element.className.match(new RegExp('(\\s|^)' + cls + '(\\s|$)')); }
    }
    function addClass(element, cls) {
        cls = trim(cls); if (cls === '') { return; }
        if (cls.indexOf(' ') !== -1) { var classes = cls.replace(/\s+/g, ' ').split(' '), i = 0, len = classes.length; for (; i < len; i++) { addClass(element, classes[ i ]); } return; }
        if (hasClass(element, cls) === false) { if (element.classList) { element.classList.add(cls); } else { element.className += ' ' + cls; } }
    }
    function removeClass(element, cls) {
        cls = trim(cls); if (cls === '') { return; }
        if (cls.indexOf(' ') !== -1) { var classes = cls.replace(/\s+/g, ' ').split(' '), i = 0, len = classes.length; for (; i < len; i++) { removeClass(element, classes[ i ]); } return; }
        if (hasClass(element, cls)) { if (element.classList) { element.classList.remove(cls); } else { element.className = element.className.replace(new RegExp('(\\s|^)' + cls + '(\\s|$)'), ' '); } }
    }
    function bind(fn, context) { if (Function.prototype.bind) { return fn.bind(context); } return function () { fn.apply(context, arrProto.slice.call(arguments)); }; }
    function extend(base, from) {
        if ($) { return $.extend({}, base, from); }
        var obj = {}, key; for (key in base) { if (base.hasOwnProperty(key)) { obj[ key ] = base[ key ]; } }
        if (from && '[object Object]' === Object.prototype.toString.call(from)) { for (key in from) { if (from.hasOwnProperty(key)) { obj[ key ] = from[ key ]; } } } return obj;
    }
    function qsa(element, query) { if ($) { return $.makeArray($(element).find(query)); } return element.querySelectorAll(query); }
    function closest(element, tag) { var c = 1, max = 20, found = element; tag = tag.toLowerCase(); while (found.tagName && found.tagName.toLowerCase() !== tag) { if (c > max || !found.parentNode) { return null; } found = found.parentNode; c++; } return found; }
    function inArray(arr, search) { if (arrProto.indexOf) { return arrProto.indexOf.call(arr, search); } for (var i = 0, len = arr.length; i < len; i++) { if (search === arr[ i ]) { return i; } } return -1; }
    if ($) { $.fn.extend({ rowSorter: function(options) { var sorters = []; this.each(function(index, element) { sorters.push(new RowSorter(element, options)); }); return sorters.length === 1 ? sorters[0] : sorters; } }); $.rowSorter = {undo: RowSorter.undo, revert: RowSorter.revert, destroy: RowSorter.destroy}; }
    return RowSorter;
  });
  </script>
  <script>
    RowSorter("#InOutTable", {
      handler: 'td.sorter',
      dragClass: 'sorting-row'
    });
  </script>
</body>
</html>
